`````md


P94: 几乎等边的三角形
可以证明, 不存在边长为整数的等边三角形其面积也是整数. 但是, 存在几乎等边的三角形 5-5-6, 其面积恰好为 12.

我们定义几乎等边的三角形是有两条边一样长, 且第三边与这两边最多相差 1 的三角形.

对于所有边长和面积均为整数且周长不超过十亿 (1,000,000,000) 的三角形, 求其中几乎等边的三角形的周长之和.

底边不能是奇数, 否则面积就会变成无理数.

设底边是 $2n$, 腰就是 $2n \pm 1$, 周长就是 $6n \pm 2$, 所以 n 的范围就出来了, 然后只要判定高 $\sqrt {5{n^2} \pm 4n + 1} $ 是否是整数就行了.

大概像这样 Select[Table[Sqrt[#1],{n,1*^6/3}],FractionalPart[#]==0&]&/@{1.0-4 n+5 n^2,1.0+4 n+5 n^2}

不行啊, 周长 10 亿呢, 得找个更强的公式...

设三边分别是 $(a,b,c) = \left( {n,n,n + 1} \right)$

$$\begin{aligned}
S &= \frac{{n + 1}}{4}\sqrt {3{n^2} - 2n - 1} \\
&\Rightarrow 3{n^2} - 2n - 1 = {y^2}\\
&\Rightarrow n = \frac{{1 \pm \sqrt {3{y^2} + 4} }}{3}\\
&\Rightarrow {x^2} - 3{y^2} = 4,(x,y) \in {N_ + }
\end{aligned}$$

佩尔方程咯.....

Reduce[{x^2-3y^2==4,x>0,y>0},{x,y},Integers]

(14,8)对应的是 (5,5,6) 差了一项, 要位移一格...

$$\left\{\begin{gathered}
{x_{i + 1}} = {\left( {2 - \sqrt 3 } \right)^i} + {\left( {\sqrt 3 + 2} \right)^i}\\
{y_{i + 1}} = \frac{{{{\left( {\sqrt 3 + 2} \right)}^i} - {{\left( {2 - \sqrt 3 } \right)}^i}}}{{\sqrt 3 }}\\
\end{gathered} \right.$$

或者写成矩阵式就是

$$\left({\begin{array}{*{20}{c}}
{{x_i}} \\ {{y_i}}
\end{array}} \right) = {\left( {\begin{array}{*{20}{c}}
2&3 \\ 1&2
\end{array}} \right)^i}\left( {\begin{array}{*{20}{c}}
4 \\ 2
\end{array}} \right)$$

然后代回原来的式子就行.

$\left({n,n,n - 1} \right)$ 作同样的推导也是这个式子, 这倒是省心了.

公式在手别说 10 亿了, 10 亿的平方都不怕了...

list=Most@NestWhileList[{{2,3},{1,2}}.#&,{14,8},#[[1]]<1*^9-1&]
Total@Map[If[Mod[First@#,3]==1,First@#-2,First@#+2]&,list]
P95: 亲和数链
一个数除了本身之外的因数称为真因数. 例如, 28 的真因数是 1, 2, 4, 7 和 14. 这些真因数的和恰好为 28, 因此我们称 28 是完全数.

有趣的是, 220 的真因数之和是 284, 同时 284 的真因数之和是 220, 构成了一个长度为 2 的链, 我们也称之为亲和数对.

有一些更长的序列并不太为人所知. 例如, 从 12496 出发, 可以构成一个长度为 5 的链:

12496 → 14288 → 15472 → 14536 → 14264 (→ 12496 → …)
由于这条链最后又回到了起点, 我们称之为亲和数链.

找出所有元素都不超过一百万的亲和数链中最长的那条, 并给出其中最小的那个数.

FindCycle[Graph[Table[i$$DirectedEdge](DivisorSigma[1,i]-i),{i,1,1*^5}]],Infinity]

然后大点就爆了.....Well...... 换个函数就好...ConnectedComponents.....

data=Table[i$$DirectedEdge](DivisorSigma[1,i]-i),{i,1*^6-1}];
gra=GatherBy[ConnectedComponents@Graph@data,Length];
First[Sort@@Last@gra]
P96: 数独
数独 (日语原意为数的位置) 是一种热门的谜题. 它的起源已不可考, 但是与欧拉发明的一种类似而更加困难的谜题拉丁方阵之间有着千丝万缕的联系. 数独的目标是替换掉 9 乘 9 网格中的空白位置(或 0), 使得每行, 每列以及每个九宫格中恰好都包含数字 1~9. 一个构造精良的数独谜题应该包含有唯一解, 且能够通过逻辑推断来解决, 尽管有时可能必须通过 "猜测并检验" 来排除一些选项(这一要求目前还颇受争议). 寻找答案的复杂度决定了题目的难度; 上面这个谜题被认为是简单的谜题, 因为我们可以通过直截了当的演绎推理来解决它.

在这个 6K 的文本文件 sudoku.txt(右击并选择 "目标另存为……") 中包含有 50 个不同难度的数独谜题, 但保证它们都只有唯一解 (文件中的第一个谜题就是上述样例).

解开这 50 个谜题, 找出每个谜题解答左上角的三个数字并连接起来, 给出这些数的和; 举例来说, 上述样例解答左上角的三个数字连接起来构成的数是 483.

按例跳过未计时, 另外回溯会超时, 最好写逻辑判别.

Get["https://raw.githubusercontent.com/GalAster/BiGridGenerator/master/BiGridGenerator/Kernel/Game/OtherGames.m"];
dat=Partition[ReadList["https://projecteuler.net/project/resources/p096_sudoku.txt",Byte,RecordLists->True],9,10,-10]-48;
First@First@Flatten[Total[FromDigits/@OtherGames`SudokuSolverFast/@dat],1]
P97: 非梅森大素数
1999 年人们发现了第一个超过一百万位的素数, 这是一个梅森素数, 可以表示为 26972593−1, 包含有 2,098,960 位数字. 在此之后, 更多形如 2p−1 的梅森素数被发现, 其位数也越来越多.

然而, 在 2004 年, 人们发现了一个巨大的非梅森素数, 包含有 2,357,207 位数字: 28433×27830457+1.

找出这个素数的最后十位数字.

快速幂模, 水过....

Mod[28433 PowerMod[2, 7830457, 1*^10] + 1, 1*^10]
P98: 重排平方数
将单词 CARE 中的四个字母依次赋值为 1, 2, 9, 6, 我们得到了一个平方数: 1296 = 362. 神奇的是, 使用同样的数字赋值, 重排后的单词 RACE 同样构成了一个平方数: 9216 = 962. 我们称 CARE 和 RACE 为重排平方单词对, 同时规定这样的单词对不允许有前导零或是不同的字母赋相同的值.

在这个 16K 的文本文件 words.txt(右击并选择 "目标另存为……") 中包含了将近两千个常见英文单词, 找出所有的重排平方单词对 (一个回文单词不视为它自己的重排).

重排平方单词对所给出的最大平方数是多少?

注意: 所有的重排单词必须出现在给定的文本文件中.

没做出来... 放弃....

本来以为 So easy 的, 直接照着说明写一遍就好了, 结果发现赋值情况有点多, 直接上估计跑到明天都跑不完...

data=Import["https://projecteuler.net/project/resources/p098_words.txt","CSV"][[1]];
Anagrams=Reverse[Select[Split[Sort[{Tally[Sort[Characters[#]]],#}&/@data],
  First[#1]==First[#2]&],Length@#>1&][[All,All,2]]]/.{a_,b_,c_}->Sequence[{a,b},{b,c},{a,c}];
(*SP=SequencePermutation*)
SP[a:{_String,_String}]:=Module[{per,sqn,l},
  per=FindPermutation[Sequence@@Characters/@a];
  l=StringLength[First@a];
  sqn=Select[#^2&/@Range[Floor[Sqrt[10^(l-1)]+1],Floor[Sqrt[10^(l)-If[EvenQ[l],1,0]]]],
    Tally[Characters[First@a]][[All,2]]==Tally[IntegerDigits[#]][[All,2]]&];
  {a,Select[{#,FromDigits@(Permute[IntegerDigits@#,per])}&/@sqn,MemberQ[sqn,#[[2]]]&&#[[1]]!=#[[2]]&]}];
MaximalBy[Select[SP/@Anagrams,Last@#!={}&],Last@Last@#&]
P99: 最大的幂
比较两个如 211 和 37 这样写成幂的形式的数并不困难, 任何计算器都能验证 211 = 2048 < 37 = 2187.

然而, 想要验证 632382518061 > 519432525806 就会变得非常困难, 因为这两个数都包含有超过三百万位数字.

22K 的文本文件 base_exp.txt(右击并选择 "目标另存为……") 有一千行, 每一行有一对底数和指数, 找出哪一行给出的幂的值最大.

注意: 文件的前两行就是上述两个例子.

高精计算, 哦不, 其实就是取个对数.... 真水.....

data=Import["https://projecteuler.net/project/resources/p099_base_exp.txt","CSV"];
Last@Ordering[N[#2 Log[#1]]&@@@data]
P100: 安排概率
在一个盒子中装有 21 个彩色碟子, 其中 15 个是蓝的, 6 个是红的. 如果随机地从盒子中取出两个碟子, 取出两个蓝色碟子的概率是 P(BB) = (15/21)×(14/20) = 1/2.

下一组使得取出两个蓝色盘子的概率恰好为 50% 的安排, 是在盒子中装有 85 个蓝色碟子和 35 个红色碟子.

当盒子中装有超过 1012 = 1,000,000,000,000 个碟子时, 找出第一组满足上述要求的安排, 并求此时盒子中蓝色碟子的数量.

$$\left\{\begin{aligned}
&\frac{{B(B - 1)}}{{N(N - 1)}} = \frac{1}{2}\\
&0 <B < {10^{12}} < N
\end{aligned} \right.$$

有点懵逼, 简单过头了吧放这, 大概是 100 题了给你们庆祝下.....

Reduce[0<b<10^12<n&&2 b(b-1)==n(n-1),{b,n},Integers]
58 分 30 秒, 欧耶, 一小时内搞定, 也就 P93 比较麻烦, 其他稍微推导一下都能有思路. P96 未计时, P98 放弃.
```

`````
