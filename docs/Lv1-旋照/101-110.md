## P101: 最优多项式

如果我们知道了一个数列的前 $k$ 项, 我们仍无法确定地给出下一项的值, 因为有无穷个多项式生成函数都有可能是这个数列的模型.

例如, 让我们考虑立方数的序列, 它可以用如下函数生成:

$$u_n = n^3: 1, 8, 27, 64, 125, 216, \dots$$

如果我们只知道数列的前两项, 秉承 "简单至上" 的原则, 我们应当假定这个数列遵循线性关系, 并且预测下一项为 $15$(公差为 $7$). 即使我们知道了数列的前三项

根据同样的原则, 我们也应当首先假定数列遵循二次函数关系.

给定数列的前 $k$ 项, 定义 $OP(k, n)$ 是由最优多项式生成函数给出的第 $n$ 项的值.

显然 $OP(k, n)$ 可以精确地给出 $n ≤ k$ 的那些项, 而可能的 ** 第一个不正确项 (First Incorrect Term, 简记为 FIT)** 将会是 $OP(k, k+1)$.

如果事实的确如此, 我们称这个多项式为 ** 坏最优多项式 (Bad OP, 简记为 BOP)**.

在最基本的情况下, 如果我们只得到了数列的第一项, 我们应当假定数列为常数, 也就是说, 对于 $n ≥ 2, OP(1, n) = u_1$.

由此, 我们得到了立方数列的最优多项式如下:

|                         |                                    |
| ----------------------- | ---------------------------------- |
| $OP(1, n) = 1$          | $1, \color{red}{1}, 1, 1, \dots$   |
| $OP(2, n) = 7n−6$       | $1, 8, \color{red}{15}, \dots$     |
| $OP(3, n) = 6n^2−11n+6$ | $1, 8, 27, \color{red}{58}, \dots$ |
| $OP(4, n) = n^3$        | $1, 8, 27, 64, 125, \dots$         |

显然, 当 $k ≥ 4$ 时不存在坏最优多项式.

所有坏最优多项式的第一个不正确项 (用 ** 红色 ** 标示的数) 之和为 $1 + 15 + 58 = 74$.

考虑下面这个十阶多项式生成函数:

$$u_n=1 - n + n^2 - n^3 + n^4 - n^5 + n^6 - n^7 + n^8 - n^9 + n^{10}$$

求其所有坏最优多项式的第一个不正确项之和.

送分题, 直接插值然后验证后一项即可

```wl
u[n_] := 1 - n + n^2 - n^3 + n^4 - n^5 + n^6 - n^7 + n^8 - n^9 + n^10
op[n_] := InterpolatingPolynomial[Array[u, n], x]
Array[op@# /. x -> # + 1&, 10] // Total
```

式子可以写成 $\displaystyle u_n=\sum _{k=0}^{10} (-n)^k$, 而且指数反人类的从小到大排列, 这是从 Mathematica 里复制出来的吧...

没事干还可以压个行:

```wl
Sum[InterpolatingPolynomial[Array[Sum[(-1)^i#^i, {i, 0, 10}]&, n], n + 1], {n, 10}]
```

## P102: 包含原点的三角形

从笛卡尔平面中随机选择三个不同的点, 其坐标均满足 $- 1000 ≤ x, y ≤ 1000$, 这三个点构成一个三角形.

考虑下面两个三角形:

$$\begin{matrix}
&A(-340,495)&B(-153,-910)&C(835,-947)\\
&X(-175,41)&Y(-421,-714)&Z(574,-645)\\
\end{matrix}$$

可以验证 $\triangle ABC$ 包含原点, 而 $\triangle XYZ$ 不包含原点.

在 27K 的文本文件 <a href="https://projecteuler.net/project/resources/p102_triangles.txt" rel="external noopener">triangles.txt</a> 中包含了一千个 "随机" 三角形的坐标, 找出其中包含原点在其内部的三角形的数量.

> 注意: 文件中的前两个三角形就是上述样例.

大概是高中解析几何难度: [Triangle Interior](http://mathworld.wolfram.com/TriangleInterior.html)

```wl
get = Import["https://projecteuler.net/project/resources/p102_triangles.txt", "CSV"];
InTriangleQ[x_, y_, {x0_, y0_, x1_, y1_, x2_, y2_}] := Block[
    {
        a = Sign[(x0 - x1) * (y - y0) - (y0 - y1) * (x - x0)],
        b = Sign[(x1 - x2) * (y - y1) - (y1 - y2) * (x - x1)],
        c = Sign[(x2 - x0) * (y - y2) - (y2 - y0) * (x - x2)]
    },
    a == 0 || b == 0 || c == 0 || (a == b && b == c)
];
Select[get, Function[tri, InTriangleQ[0, 0, tri]]] // Length
```

不过其实有内置函数, 一行流走一波:

```wl
Count[RegionMember[Triangle@Partition[#, 2], {0, 0}]& /@ get, True]
Count[SignedRegionDistance[Triangle[#], {0., 0}]& /@ Map[Partition[#, 2]&, get], _?Negative]
```

第一种直接判定居然比第二种计算距离还慢也是无敌, 比我手写外加没编译的函数还慢真的无敌.

-  计时: 17:23.49

## P103: 特殊的子集和: 最优解

记 $S(A)$ 是大小为 $n$ 的集合 $A$ 中所有元素的和.

若任取 $A$ 的任意两个非空且不相交的子集 $B$ 和 $C$ 都满足下列条件, 我们称 $A$ 是一个特殊的和集:

1. $S(B) \neq S(C)$; 也就是说, 任意子集的和不相同.
2. 如果 $B$ 中的元素比 $C$ 多, 则 $S(B) > S(C)$.

对于给定的 $n$, 我们称使得 $S(A)$ 最小的集合 $A$ 为最优特殊和集.

前 5 个最优特殊和集如下所示.

* $n = 1: \{1\}$
* $n = 2: \{1, 2\}$
* $n = 3: \{2, 3, 4\}$
* $n = 4: \{3, 5, 6, 7\}$
* $n = 5: \{6, 9, 11, 12, 13\}$

_似乎_对于一个给定的最优特殊和集 $A=\{a_1,a_2,\cdots,a_n\}$, 下一个最优特殊和集将是 $B=\{b,a_1+b,a_2+b,\cdots,a_n+b\}$ 的形式, 其中 $b$ 是集合 $A$"正中间" 的元素.

应用这条 "规则", 我们猜测对于 $n = 6$ 的最优特殊和集将是 $A = \{11, 17, 20, 22, 23, 24\}$ , 相应的 $S(A) = 117$.

然而, 事实并非如此, 我们的方法仅仅只能找出近似最优特殊和集.

对于 $n = 6$, 最优特殊和集是 $A = \{11, 18, 19, 20, 22, 25\}$, 相应的 $S(A) = 115$, 对应的集合数字串是:$111819202225$.

若集合 $A$ 是 $n = 7$ 时的最优特殊和集, 求其对应的集合数字串.

我是在做江苏高考的数列压轴题吗, 这都什么鬼啊...

还带一个错误的猜测的说, 和阅读理解似的.

这规则到底有啥用啊, 题看起来就想要暴搜一样, 但是给了你个范围吗......

看起来像是 $±1$ 搜一下就行了?

更加神经病的是, $n=7$ 的情况不是反例...

```wl
t = 20 + {0, 11, 18, 19, 20, 22, 25}
g = # + t& /@ Tuples[Range[-1, 1], {7}];
sQ[l_] := Length@DeleteDuplicates@# == Length@#&@(Total /@ Subsets[l]);
StringRiffle[SortBy[Select[g, sQ], Total] // First, ""]
```

喂, 什么破题, 我想了半个小时不知这题在干嘛

后来查了下这个还和一个叫 k-SSD 的问题有点关系, 链接: [SUBSET-SUM-DISTINCT SEQUENCE]([)http://www.mathnet.or.kr/mathnet/kms_tex/981074.pdf)

- 计时: 31:10.34

## P104: 两端为全数字的斐波那契数

斐波那契数列由如下递归关系生成:

$$F_n=F_{n-1}+F_{n-2},F_1=F_2=1$$

可以发现, 包含有 $113$ 位数字的 $F_{541}$ 是第一个后 $9$ 位数字是 $1$ 至 $9$ 全数字 (包含 $1$ 至 $9$ 所有的数字, 但不一定按照从小到大的顺序) 的斐波那契数;

而包含有 $575$ 位数字的 $F_{2749}$ 是第一个前 $9$ 位数字是 $1$ 至 $9$ 全数字的斐波那契数.

若 $F_k$ 是第一个前 9 位数字和后 9 位数字都是 1 至 9 全数字的斐波那契数, 求 k.

虽然 Mathematica 有内置的函数, 不过你真去算就中计了

虽然暴力也不是不能一分钟内搞定, 但是人家只要前九位后九位, 你干嘛做那么多无用功呢

前九位直接数值近似就行, 后九位用带模加法, 这样时空复杂度就都低了不是.

```wl
NextFib[{n_, f1_, f2_}] := Mod[{n + 1, f2, f1 + f2}, 1*^9];
First9[n_] := First@RealDigits[GoldenRatio^n / Sqrt[5], 10, 9];
PanQ = Sort[#] == Range[9]&;
Test[{n_, f1_, f2_}] := !(PanQ@IntegerDigits[f2] && PanQ@First9[n]);
NestWhile[NextFib, {2, 1, 1}, Test] // First
```

- 计时: 9:00.88


---


| 编号 | 计时 |
| :--- | :--- |
| P101 | 2:15 |
| P102 |
| P103 |
| P104 |
| P105 |
| P106 |
| P107 |
| P108 |
| P109 |
| P110 |
