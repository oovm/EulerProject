`````md
## P121: 碟子游戏奖金

一开始, 包里装有一个红色碟子和一个蓝色碟子. 在一场概率游戏中, 每一轮玩家从包中取出一个碟子, 记录下其颜色, 随后将碟子放回包中, 并在包中加入一个红色碟子, 再进行下一轮.

玩家需要付￡1 来玩这个游戏, 如果他们在游戏结束时拿出的蓝色碟子数比红色碟子数更多, 则获得胜利.

如果游戏进行 4 轮, 那么玩家获胜的概率是 11/120, 因此游戏所设定的最高奖金为￡10, 否则可能会造成亏损. 注意奖金必须是整数, 而且包含了玩家付出用于玩游戏的￡1, 也就是说玩家实际上赢得的数额是￡9.

如果游戏进行 15 轮, 求游戏所设定的最高奖金.


## P122: 高效指数计算

计算 n^15 最朴素的方式需要 14 次乘法:

n × n × … × n = n^15

但使用一个 "二进制" 的算法, 你可以只用 6 次乘法:

n × n = n^2
n^2 × n^2 = n^4
n^4 × n^4 = n^8
n^8 × n^4 = n^12
n^12 × n^2 = n^14
n^14 × n = n^15

然而, 实际上仅用 5 次乘法也是可以的:

n × n = n^2
n^2 × n = n^3
n^3 × n^3 = n^6
n^6 × n^6 = n^12
n^12 × n^3 = n^15

记 m(k) 是计算 n^k 所需要的最少次数, 例如 m(15) = 5.

对于 1 ≤ k ≤ 200, 求∑m(k).

## P123: 素数平方余数

记 p_n 是第 n 个素数: 2, 3, 5, 7, 11……; 记 r 是 (p_n?1)^n + (p_n+1)^n 被 p_n^2 除所得的余数.

例如, 当 n = 3 时, p_3 = 5, 而 4^3 + 6^3 = 280 ≡ 5 mod 25.

使余数首次超过 10^9 的最小 n 值是 7037.

求使余数首次超过 10^10 的最小 n 值.

## P124: 基排序

数 n 的基 rad(n), 是指 n 的不同质因数之积. 例如, 504 = 2^3 × 3^2 × 7, 所以 rad(504) = 2 × 3 × 7 = 42.

如果我们计算 1 ≤ n ≤ 10 的 rad(n), 并先按照 rad(n) 再按照 n 从小到大排序, 我们得到:

|     | ** 排序前 ** |  |  | ** 排序后 ** |  |
| --- | ------------ || ----- | ---------- | ----- |
| **n** | **rad(n)** |  | **n** | **rad(n)** | **k** |
| 1     | 1          |  | 1     | 1          | 1     |
| 2     | 2          |  | 2     | 2          | 2     |
| 3     | 3          |  | 4     | 2          | 3     |
| 4     | 2          |  | 8     | 2          | 4     |
| 5     | 5          |  | 3     | 3          | 5     |
| 6     | 6          |  | 9     | 3          | 6     |
| 7     | 7          |  | 5     | 5          | 7     |
| 8     | 2          |  | 6     | 6          | 8     |
| 9     | 3          |  | 7     | 7          | 9     |
| 10    | 10         |  | 10    | 10         | 10    |

记 E(k) 是前 n 个数排序后的第 k 个数, 例如, E(4) = 8 以及 E(6) = 9.

对 1 ≤ n ≤ 100000 按照 rad(n) 排序后, 求 E(10000).


## P125: 回文和

回文数 595 很有趣, 因为它可以写成连续平方数的和: 6^2 + 7^2 + 8^2 + 9^2 + 10^2 + 11^2 + 12^2.

恰好有十一个小于一千的回文数可以写成连续平方数的和, 这些回文数的和是 4164. 注意 1 = 0^2+ 1^2 并没有算在内, 因为本题只考虑正整数的平方.

在小于 10^8 的数中, 找出所有可以写成连续平方数的和的回文数, 并求它们的和.


## P126: 立方体层

要完全包住一个 3x2x1 的长方体的表面, 最少需要的立方体数目为 22.

<center>
  <a class="fancybox" href="../wp-content/uploads/2018/06/053cc8c312cbed4329a142e6865970f2.gif"><img src="../wp-content/uploads/2018/06/053cc8c312cbed4329a142e6865970f2.gif" alt=""width="499"height="247" /></a>
</center> 如果我们要再包一层, 需要 46 个立方体才能挡住所有表面, 而第三层需要 78 个立方体, 第 4 层则需要 180 个立方体.

同样地, 要完全包住一个 5x1x1 的长方体的表面也需要 22 个立方体. 而要包住 5x3x1 或是 7x2x1 或是 11x1x1 的长方体表面, 第一层就需要 46 个立方体.

记 C(n) 是在任意一层中需要 n 个立方体的长方体数目. 所以 C(22) = 2, C(46) = 4, C(78) = 5, C(118) = 8.

可以验证 154 是第一个使得 C(n) = 10 的 n.

找出使得 C(n) = 1000 的最小的 n.



## P127: abc 匹配

数 n 的基 rad(n) 被定义为 n 的不同质因数之积. 例如 504 = 2^3 × 3^2 × 7, 所以 rad(504) = 2 × 3 × 7 = 42.

我们定义正整数三元组 (a, b, c) 为 abc 匹配, 当其满足如下条件:

  1. GCD(a, b) = GCD(a, c) = GCD(b, c) = 1
  2. a < b
  3. a + b = c
  4. rad(abc) < c

例如, (5, 27, 32) 是一个 abc 匹配, 因为:

  1. GCD(5, 27) = GCD(5, 32) = GCD(27, 32) = 1
  2. 5 < 27
  3. 5 + 27 = 32
  4. rad(4320) = 30 < 32

实际上, abc 匹配是非常稀少的, 对于 c < 1000, 只有 31 组 abc 匹配, 在这些匹配中∑c = 12523.

对于 c < 120000, 求∑c.


## P128: 六边形地砖的差

标有数 1 的六边形地砖被一圈六个六边形地砖包围, 这些地砖从 12 点钟方向 (正上方) 开始沿逆时针顺序依次标记为 2 至 7.

在这个图形的外面, 继续加上新的六边形地砖, 接下来的几圈分别按照同样的规则标上 8 至 19, 20 至 37, 38 至 61, 依此类推. 下图显示了前三圈所构成的图形.

<center>
  <a class="fancybox" href="../wp-content/uploads/2018/06/ed3a05d48789410cc5bf46f031afe889.gif"><img src="../wp-content/uploads/2018/06/ed3a05d48789410cc5bf46f031afe889.gif" alt=""width="400"height="431" /></a>
</center> 考虑标有 n 的地砖与其周围六块地砖的差, 我们定义 PD(n) 是这些差中素数的数目.

例如, 按顺时针顺序, 标有 8 的地砖与周围地砖的差是 12, 29, 11, 6, 1 和 13. 所以 PD(8) = 3.

同样的, 标有 17 的地砖与周围地砖的差是 1, 17, 16, 1, 11 和 10, 所以 PD(17) = 2.

可以验证, PD(n) 的最大值就是 3.

如果所有 PD(n) = 3 的地砖构成从小到大排列的序列, 那么第 10 块将是标有 271 的地砖.

找出这个序列中的第 2000 块地砖所标的数.





## P129: 循环单位数整除性

只包含数字 1 的数被称为循环单位数, 我们定义 R(k) 是长为 k 的循环单位数, 例如, R(6) = 111111.

如果 n 是一个整数, 且 GCD(n, 10) = 1, 可以验证总存在 k 使得 R(k) 能够被 n 整除, 并且记 A(n) 是这些 k 中最小的一个. 例如, A(7) = 6, 而 A(41) = 5.

使得 A(n) 第一次超过十的 n 是 17.

求使得 A(n) 第一次超过一千万的 n.





## P130: 满足素数循环单位数性质的合数

只包含数字 1 的数被称为循环单位数, 我们定义 R(k) 是长为 k 的循环单位数, 例如, R(6) = 111111.

如果 n 是一个整数, 且 GCD(n, 10) = 1, 可以验证总存在 k 使得 R(k) 能够被 n 整除, 并且记 A(n) 是这些 k 中最小的一个. 例如, A(7) = 6, 而 A(41) = 5.

已知对于素数 p > 5, p − 1 能够被 A(p) 整除. 例如, 当 p = 41 时, A(41) = 5, 而 40 能够被 5 整除.

然而, 有很少的一部分合数也满足这条性质, 前 5 个这样的数分别是 91, 259, 451, 481 以及 703.

找出前 25 个合数 n 满足
GCD(n, 10) = 1 且 n − 1 能够被 A(n) 整除, 并求它们的和.
