## P91: 格点直角三角形

点 P(x1, y1) 和点 Q(x2, y2) 都是格点, 并与原点 O(0,0) 构成ΔOPQ.


当点 P 和点 Q 的所有坐标都在 0 到 2 之间, 也就是说 0 ≤ x1, y1, x2, y2 ≤ 2 时, 恰好能构造出 14 个直角三角形.


如果 0 ≤ x1, y1, x2, y2 ≤ 50, 能构造出多少个直角三角形?

看到这种题第一反应就是生成函.... 那啥.... 我又看出规律了.....

编号 1-14, 对于 s×s 的正方形, 首先有三种简单的情况, 就是 1,2,10 以及 8,9,14 这种直角在角上的.$3{s^2}$ 到手.

不在角上的就比较麻烦了... 画个草图





设直角那个叫 $P({x_1},{y_1})$. 然后就是 $P({x_1},{y_1}),Q({x_2},{y_2}),O({x_0},{y_0})$.

$$ \begin{aligned}
&\because OP \bot PQ \\
&\therefore \overrightarrow{OP} \cdot \overrightarrow{PQ} = 0 \\
&\Rightarrow {x_1}{x_2} + {y_1}{y_2} = x_1^2 + y_1^2
\end{aligned}$$

化简下, 于是就从几何问题转化为了代数问题, 求这个的整数解. 这时候开始穷举也行, 不过还能化简公式.

$$ \begin{aligned}
&\quad\ \left\{\begin{gathered}
{x_2} = {x_1} + a\\
{y_2} = {y_1} + b\\
\end{gathered} \right.\\
&\Rightarrow a{x_1} + b{y_1} = 0\\
&\quad\ d = GCD({x_1},{y_1})\\
&\Rightarrow (a,b) = ( - \frac{{{y_1}}}{d}n,\frac{{{x_1}}}{d}n)\\
&\Rightarrow f(s) = Min(\frac{{{y_1}}}{{{x_1}}}d,\frac{{s - {x_1}}}{{{y_1}}}d)\\
&\Rightarrow S = \sum\limits_{0 < {x_1},{y_1} < s} {f(s)} + 3{s^2}
\end{aligned}$$

翻译成代码, 根据对称性卡死 ${x_1} < {y_2}$, 这样还可以少一半计算量, 最后乘以 2 补回去.

Function[s,2 Total[Array[Min@Quotient[{#2,s-#},{##}/GCD@##]&,{s,s}],2]+3 s^2]@50

### 92: 平方数字链

将一个数的所有数字的平方相加得到一个新的数, 不断重复直到新的数已经出现过为止, 这构成了一条数字链.

例如,

44 → 32 → 13 → 10 → 1 → 1
85 → 89 → 145 → 42 → 20 → 4 → 16 → 37 → 58 → 89

可见, 任何一个到达 1 或 89 的数字链都会陷入无尽的循环. 更令人惊奇的是, 从任意数开始, 最终都会到达 1 或 89.

有多少个小于一千万的数最终会到达 89?

硬计算差评, 还有我又一次没看到小于号..... 虽然不影响结果...

foo=Total[IntegerDigits[#]^2]&;
bar[1]=1;bar[89]=89;bar[n_]:=bar[n]=bar@foo@n
Tally[ParallelMap[bar,Range[1*^7]]]

## P93: 算术表达式

使用集合 {1, 2, 3, 4} 中每个数字恰好一次以及 (+, −, *, /) 四则运算和括号, 可以得到不同的正整数.

例如,

8 = (4 * (1 + 3)) / 2
14 = 4 * (3 + 1 / 2)
19 = 4 * (2 + 3) − 1
36 = 3 * 4 * (2 + 1)

注意不允许直接把数字连起来, 如 12 + 34.

使用集合 {1, 2, 3, 4}, 可以得到 31 个不同的数, 其中最大值是 36, 以及 1 到 28 之间所有的数.

若使用包含有四个不同数字 a < b < c < d 的集合可以得到从 1 到 n 之间所有的数, 求其中使得 n 最大的集合, 并将你的答案写成字符串: abcd.

9 个数字选 4 个, C(9,4)=126. 四个符号选三个 C(4,3)=4,7 个位子 8 个空选两个放括号 C(8,2)=28, 全部乘起来也不大...

没括号的 64 种情况下是这样的, 好吧我就是想秀一下我珍藏多年的强力函数.....

ListToExpression[list_]:=list//.({x___,PatternSequence[a_,u:#,b_],y___}:>{x,u[a,b],y}&/@{Power|Log|Surd,Times|Divide,Plus|Subtract});
OperatorRiffle[exp_,oper_:{Times,Divide,Plus,Subtract}] :=Grid[{#,ListToExpression@#}&/@(Riffle[exp,#]&/@Tuples[oper,Length@exp-1]),Alignment->Left];
OperatorRiffle[{a,b,c,d}]

虽然后来我想到这个其实直接变字符串然后连起来然后读回表达式就行.... 不过那样就无法装逼了...

而且这个方法对于 Log,Surd 这类非算子也有效, 强制解释为最高级算子. 而且运算优先级完全可以魔改, 我就是规定加法优先乘法怎么着.....

注意相减算子是 SubMinus,Minus 是取负, 不是个算子. MinusPlus, PlusMinus 正负号, 负正号这俩就连运算都不是了, 只是个保留符号罢了.

Ok, 回到这道题, 不管怎么样我们就考虑怎么穷举出 a,b,c,d 的所有计算结果好了.

```wl
AllResults[L_] := If[Length[L] == 1, L, DeleteDuplicates@Flatten@Table[With[{c = AllResults@DeleteCases[L, x]}, {x + c, x - c, x * c, x / c, c / x, c - x}], {x, L}]];
FinalResults[L_] := Sort@Select[AllResults[L], IntegerQ[#] && # > 0&];
SeqLength[L_] := With[{res = FinalResults@L}, If[Length@res == 0 || First@res != 1, 0, First@FirstPosition[Differences@res, x_ /; x != 1]]];
MaximalBy[Subsets[Range[9], {4}], SeqLength]
```
